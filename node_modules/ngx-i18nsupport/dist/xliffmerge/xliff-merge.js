"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var program = require("commander");
var command_output_1 = require("../common/command-output");
var xliff_merge_parameters_1 = require("./xliff-merge-parameters");
var xliff_merge_error_1 = require("./xliff-merge-error");
var file_util_1 = require("../common/file-util");
var version_1 = require("./version");
var util_1 = require("util");
var ngx_i18nsupport_lib_1 = require("ngx-i18nsupport-lib");
var ngx_translate_extractor_1 = require("./ngx-translate-extractor");
var translation_messages_file_reader_1 = require("./translation-messages-file-reader");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var xliff_merge_auto_translate_service_1 = require("../autotranslate/xliff-merge-auto-translate-service");
var auto_translate_summary_report_1 = require("../autotranslate/auto-translate-summary-report");
var dist_1 = require("ngx-i18nsupport-lib/dist");
/**
 * Created by martin on 17.02.2017.
 * XliffMerge - read xliff or xmb file and put untranslated parts in language specific xliff or xmb files.
 *
 */
var XliffMerge = /** @class */ (function () {
    function XliffMerge(commandOutput, options) {
        this.commandOutput = commandOutput;
        this.options = options;
        this.parameters = null;
    }
    XliffMerge.main = function (argv) {
        var options = XliffMerge.parseArgs(argv);
        new XliffMerge(new command_output_1.CommandOutput(process.stdout), options).run(function (result) {
            process.exit(result);
        });
    };
    XliffMerge.parseArgs = function (argv) {
        var languages = null;
        delete program.verbose;
        delete program.quiet;
        delete program.profilePath;
        delete program.languages;
        program
            .version(version_1.VERSION)
            .arguments('<language...>')
            .option('-p, --profile [configfile]', 'a json configuration file containing all relevant parameters (see details below)')
            .option('-v, --verbose', 'show some output for debugging purposes')
            .option('-q, --quiet', 'only show errors, nothing else')
            .on('--help', function () {
            console.log('  <language> has to be a valid language short string, e,g. "en", "de", "de-ch"');
            console.log('');
            console.log('  configfile can contain the following values:');
            console.log('\tquiet verbose defaultLanguage languages srcDir i18nBaseFile i18nFile i18nFormat encoding genDir' +
                '\n\tremoveUnusedIds allowIdChange' +
                '\n\tsupportNgxTranslate ngxTranslateExtractionPattern' +
                '\n\tuseSourceAsTarget targetPraefix targetSuffix' +
                '\n\tautotranslate apikey apikeyfile');
            console.log('\tfor details please consult the home page https://github.com/martinroob/ngx-i18nsupport');
        })
            .action(function (languageArray) {
            languages = languageArray;
        })
            .parse(argv);
        var options = {
            languages: languages
        };
        if (program.profile) {
            options.profilePath = program.profile;
        }
        if (program.quiet) {
            options.quiet = true;
        }
        if (program.verbose && program.verbose > 0) {
            options.verbose = true;
        }
        return options;
    };
    /**
     * For Tests, create instance with given profile
     * @param commandOutput
     * @param options
     * @param profileContent
     */
    XliffMerge.createFromOptions = function (commandOutput, options, profileContent) {
        var instance = new XliffMerge(commandOutput, options);
        instance.parameters = xliff_merge_parameters_1.XliffMergeParameters.createFromOptions(options, profileContent);
        return instance;
    };
    /**
     * Run the command.
     * This runs async.
     * @param callbackFunction when command is executed, called with the return code (0 for ok), if given.
     * @param errorFunction callbackFunction for error handling
     */
    XliffMerge.prototype.run = function (callbackFunction, errorFunction) {
        this.doRun()
            .subscribe(function (retcode) {
            if (!util_1.isNullOrUndefined(callbackFunction)) {
                callbackFunction(retcode);
            }
        }, function (error) {
            if (!util_1.isNullOrUndefined(errorFunction)) {
                errorFunction(error);
            }
        });
    };
    /**
     * Execute merge-Process.
     * @return Async operation, on completion returns retcode 0=ok, other = error.
     */
    XliffMerge.prototype.doRun = function () {
        var _this = this;
        if (this.options && this.options.quiet) {
            this.commandOutput.setQuiet();
        }
        if (this.options && this.options.verbose) {
            this.commandOutput.setVerbose();
        }
        if (!this.parameters) {
            this.parameters = xliff_merge_parameters_1.XliffMergeParameters.createFromOptions(this.options);
        }
        this.commandOutput.info('xliffmerge version %s', version_1.VERSION);
        if (this.parameters.verbose()) {
            this.parameters.showAllParameters(this.commandOutput);
        }
        if (this.parameters.errorsFound.length > 0) {
            for (var _i = 0, _a = this.parameters.errorsFound; _i < _a.length; _i++) {
                var err = _a[_i];
                this.commandOutput.error(err.message);
            }
            return rxjs_1.of(-1);
        }
        if (this.parameters.warningsFound.length > 0) {
            for (var _b = 0, _c = this.parameters.warningsFound; _b < _c.length; _b++) {
                var warn = _c[_b];
                this.commandOutput.warn(warn);
            }
        }
        this.readMaster();
        if (this.parameters.autotranslate()) {
            this.autoTranslateService = new xliff_merge_auto_translate_service_1.XliffMergeAutoTranslateService(this.parameters.apikey());
        }
        var executionForAllLanguages = [];
        this.parameters.languages().forEach(function (lang) {
            executionForAllLanguages.push(_this.processLanguage(lang));
        });
        return rxjs_1.forkJoin(executionForAllLanguages).pipe(operators_1.map(function (retcodes) { return _this.totalRetcode(retcodes); }));
    };
    /**
     * Give an array of retcodes for the different languages, return the total retcode.
     * If all are 0, it is 0, otherwise the first non zero.
     * @param retcodes
     * @return {number}
     */
    XliffMerge.prototype.totalRetcode = function (retcodes) {
        for (var i = 0; i < retcodes.length; i++) {
            if (retcodes[i] !== 0) {
                return retcodes[i];
            }
        }
        return 0;
    };
    /**
     * Return the name of the generated file for given lang.
     * @param lang
     * @return {string}
     */
    XliffMerge.prototype.generatedI18nFile = function (lang) {
        return this.parameters.generatedI18nFile(lang);
    };
    /**
     * Return the name of the generated ngx-translation file for given lang.
     * @param lang
     * @return {string}
     */
    XliffMerge.prototype.generatedNgxTranslateFile = function (lang) {
        return this.parameters.generatedNgxTranslateFile(lang);
    };
    /**
     * Warnings found during the run.
     * @return {string[]}
     */
    XliffMerge.prototype.warnings = function () {
        return this.parameters.warningsFound;
    };
    XliffMerge.prototype.readMaster = function () {
        var _this = this;
        try {
            this.master = translation_messages_file_reader_1.TranslationMessagesFileReader.fromFile(this.parameters.i18nFormat(), this.parameters.i18nFile(), this.parameters.encoding());
            this.master.warnings().forEach(function (warning) {
                _this.commandOutput.warn(warning);
            });
            var count = this.master.numberOfTransUnits();
            var missingIdCount = this.master.numberOfTransUnitsWithMissingId();
            this.commandOutput.info('master contains %s trans-units', count);
            if (missingIdCount > 0) {
                this.commandOutput.warn('master contains %s trans-units, but there are %s without id', count, missingIdCount);
            }
            var sourceLang = this.master.sourceLanguage();
            if (sourceLang && sourceLang !== this.parameters.defaultLanguage()) {
                this.commandOutput.warn('master says to have source-language="%s", should be "%s" (your defaultLanguage)', sourceLang, this.parameters.defaultLanguage());
                this.master.setSourceLanguage(this.parameters.defaultLanguage());
                translation_messages_file_reader_1.TranslationMessagesFileReader.save(this.master, this.parameters.beautifyOutput());
                this.commandOutput.warn('changed master source-language="%s" to "%s"', sourceLang, this.parameters.defaultLanguage());
            }
        }
        catch (err) {
            if (err instanceof xliff_merge_error_1.XliffMergeError) {
                this.commandOutput.error(err.message);
                return rxjs_1.of(-1);
            }
            else {
                // unhandled
                var currentFilename = this.parameters.i18nFile();
                var filenameString = (currentFilename) ? util_1.format('file "%s", ', currentFilename) : '';
                this.commandOutput.error(filenameString + 'oops ' + err);
                throw err;
            }
        }
    };
    /**
     * Process the given language.
     * Async operation.
     * @param lang
     * @return {Observable<number>} on completion 0 for ok, other for error
     */
    XliffMerge.prototype.processLanguage = function (lang) {
        var _this = this;
        this.commandOutput.debug('processing language %s', lang);
        var languageXliffFile = this.parameters.generatedI18nFile(lang);
        var currentFilename = languageXliffFile;
        var result;
        if (!file_util_1.FileUtil.exists(languageXliffFile)) {
            result = this.createUntranslatedXliff(lang, languageXliffFile);
        }
        else {
            result = this.mergeMasterTo(lang, languageXliffFile);
        }
        return result
            .pipe(operators_1.map(function () {
            if (_this.parameters.supportNgxTranslate()) {
                var languageSpecificMessagesFile = translation_messages_file_reader_1.TranslationMessagesFileReader.fromFile(XliffMerge.translationFormat(_this.parameters.i18nFormat()), languageXliffFile, _this.parameters.encoding(), _this.master.filename());
                ngx_translate_extractor_1.NgxTranslateExtractor.extract(languageSpecificMessagesFile, _this.parameters.ngxTranslateExtractionPattern(), _this.parameters.generatedNgxTranslateFile(lang));
            }
            return 0;
        }), operators_1.catchError(function (err) {
            if (err instanceof xliff_merge_error_1.XliffMergeError) {
                _this.commandOutput.error(err.message);
                return rxjs_1.of(-1);
            }
            else {
                // unhandled
                var filenameString = (currentFilename) ? util_1.format('file "%s", ', currentFilename) : '';
                _this.commandOutput.error(filenameString + 'oops ' + err);
                throw err;
            }
        }));
    };
    /**
     * create a new file for the language, which contains no translations, but all keys.
     * in principle, this is just a copy of the master with target-language set.
     * @param lang
     * @param languageXliffFilePath
     */
    XliffMerge.prototype.createUntranslatedXliff = function (lang, languageXliffFilePath) {
        var _this = this;
        // copy master ...
        // and set target-language
        // and copy source to target if necessary
        var isDefaultLang = (lang == this.parameters.defaultLanguage());
        this.master.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
        this.master.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
        var languageSpecificMessagesFile = this.master.createTranslationFileForLang(lang, languageXliffFilePath, isDefaultLang, this.parameters.useSourceAsTarget());
        return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile).pipe(operators_1.map(function (summary) {
            // write it to file
            translation_messages_file_reader_1.TranslationMessagesFileReader.save(languageSpecificMessagesFile, _this.parameters.beautifyOutput());
            _this.commandOutput.info('created new file "%s" for target-language="%s"', languageXliffFilePath, lang);
            if (!isDefaultLang) {
                _this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
            }
            return null;
        }));
    };
    /**
     * Map the input format to the format of the translation.
     * Normally they are the same but for xmb the translation format is xtb.
     * @param i18nFormat
     */
    XliffMerge.translationFormat = function (i18nFormat) {
        if (i18nFormat === ngx_i18nsupport_lib_1.FORMAT_XMB) {
            return ngx_i18nsupport_lib_1.FORMAT_XTB;
        }
        else {
            return i18nFormat;
        }
    };
    /**
     * Merge all
     * @param lang
     * @param languageXliffFilePath
     */
    XliffMerge.prototype.mergeMasterTo = function (lang, languageXliffFilePath) {
        var _this = this;
        // read lang specific file
        var languageSpecificMessagesFile = translation_messages_file_reader_1.TranslationMessagesFileReader.fromFile(XliffMerge.translationFormat(this.parameters.i18nFormat()), languageXliffFilePath, this.parameters.encoding());
        var isDefaultLang = (lang == this.parameters.defaultLanguage());
        var newCount = 0;
        var correctSourceContentCount = 0;
        var correctSourceRefCount = 0;
        var correctDescriptionOrMeaningCount = 0;
        var idChangedCount = 0;
        languageSpecificMessagesFile.setNewTransUnitTargetPraefix(this.parameters.targetPraefix());
        languageSpecificMessagesFile.setNewTransUnitTargetSuffix(this.parameters.targetSuffix());
        var lastProcessedUnit = null;
        this.master.forEachTransUnit(function (masterTransUnit) {
            var transUnit = languageSpecificMessagesFile.transUnitWithId(masterTransUnit.id);
            if (!transUnit) {
                // oops, no translation, must be a new key, so add it
                var newUnit = void 0;
                if (_this.parameters.allowIdChange() && (newUnit = _this.processChangedIdUnit(masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit))) {
                    lastProcessedUnit = newUnit;
                    idChangedCount++;
                }
                else {
                    lastProcessedUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, isDefaultLang, _this.parameters.useSourceAsTarget(), lastProcessedUnit);
                    newCount++;
                }
            }
            else {
                // check for changed source content and change it if needed
                // (can only happen if ID is explicitely set, otherwise ID would change if source content is changed.
                if (transUnit.supportsSetSourceContent() && masterTransUnit.sourceContent() !== transUnit.sourceContent()) {
                    transUnit.setSourceContent(masterTransUnit.sourceContent());
                    if (isDefaultLang) {
                        // #81 changed source must be copied to target for default lang
                        transUnit.translate(masterTransUnit.sourceContent());
                        transUnit.setTargetState(dist_1.STATE_FINAL);
                    }
                    else {
                        if (transUnit.targetState() == dist_1.STATE_FINAL) {
                            // source is changed, so translation has to be checked again
                            transUnit.setTargetState(dist_1.STATE_TRANSLATED);
                        }
                    }
                    correctSourceContentCount++;
                }
                // check for missing or changed source ref and add it if needed
                if (transUnit.supportsSetSourceReferences() && !_this.areSourceReferencesEqual(masterTransUnit.sourceReferences(), transUnit.sourceReferences())) {
                    transUnit.setSourceReferences(masterTransUnit.sourceReferences());
                    correctSourceRefCount++;
                }
                // check for changed description or meaning
                if (transUnit.supportsSetDescriptionAndMeaning()) {
                    var changed = false;
                    if (transUnit.description() !== masterTransUnit.description()) {
                        transUnit.setDescription(masterTransUnit.description());
                        changed = true;
                    }
                    if (transUnit.meaning() !== masterTransUnit.meaning()) {
                        transUnit.setMeaning(masterTransUnit.meaning());
                        changed = true;
                    }
                    if (changed) {
                        correctDescriptionOrMeaningCount++;
                    }
                }
                lastProcessedUnit = transUnit;
            }
        });
        if (newCount > 0) {
            this.commandOutput.warn('merged %s trans-units from master to "%s"', newCount, lang);
        }
        if (correctSourceContentCount > 0) {
            this.commandOutput.warn('transferred %s changed source content from master to "%s"', correctSourceContentCount, lang);
        }
        if (correctSourceRefCount > 0) {
            this.commandOutput.warn('transferred %s source references from master to "%s"', correctSourceRefCount, lang);
        }
        if (idChangedCount > 0) {
            this.commandOutput.warn('found %s changed id\'s in "%s"', idChangedCount, lang);
        }
        if (correctDescriptionOrMeaningCount > 0) {
            this.commandOutput.warn('transferred %s changed descriptions/meanings from master to "%s"', correctDescriptionOrMeaningCount, lang);
        }
        // remove all elements that are no longer used
        var removeCount = 0;
        languageSpecificMessagesFile.forEachTransUnit(function (transUnit) {
            var existsInMaster = !util_1.isNullOrUndefined(_this.master.transUnitWithId(transUnit.id));
            if (!existsInMaster) {
                if (_this.parameters.removeUnusedIds()) {
                    languageSpecificMessagesFile.removeTransUnitWithId(transUnit.id);
                }
                removeCount++;
            }
        });
        if (removeCount > 0) {
            if (this.parameters.removeUnusedIds()) {
                this.commandOutput.warn('removed %s unused trans-units in "%s"', removeCount, lang);
            }
            else {
                this.commandOutput.warn('keeping %s unused trans-units in "%s", because removeUnused is disabled', removeCount, lang);
            }
        }
        if (newCount == 0 && removeCount == 0 && correctSourceContentCount == 0 && correctSourceRefCount == 0 && correctDescriptionOrMeaningCount == 0) {
            this.commandOutput.info('file for "%s" was up to date', lang);
            return rxjs_1.of(null);
        }
        else {
            return this.autoTranslate(this.master.sourceLanguage(), lang, languageSpecificMessagesFile)
                .pipe(operators_1.map(function () {
                // write it to file
                translation_messages_file_reader_1.TranslationMessagesFileReader.save(languageSpecificMessagesFile, _this.parameters.beautifyOutput());
                _this.commandOutput.info('updated file "%s" for target-language="%s"', languageXliffFilePath, lang);
                if (newCount > 0 && !isDefaultLang) {
                    _this.commandOutput.warn('please translate file "%s" to target-language="%s"', languageXliffFilePath, lang);
                }
                return null;
            }));
        }
    };
    /**
     * Handle the case of changed id due to small white space changes.
     * @param {ITransUnit} masterTransUnit unit in master file
     * @param {ITranslationMessagesFile} languageSpecificMessagesFile translation file
     * @param lastProcessedUnit Unit before the one processed here. New unit will be inserted after this one.
     * @return {ITransUnit} processed unit, if done, null if no changed unit found
     */
    XliffMerge.prototype.processChangedIdUnit = function (masterTransUnit, languageSpecificMessagesFile, lastProcessedUnit) {
        var masterSourceString = masterTransUnit.sourceContentNormalized().asDisplayString(dist_1.NORMALIZATION_FORMAT_DEFAULT).trim();
        var changedTransUnit = null;
        languageSpecificMessagesFile.forEachTransUnit(function (languageTransUnit) {
            if (languageTransUnit.sourceContentNormalized().asDisplayString(dist_1.NORMALIZATION_FORMAT_DEFAULT).trim() === masterSourceString) {
                changedTransUnit = languageTransUnit;
            }
        });
        if (!changedTransUnit) {
            return null;
        }
        var mergedTransUnit = languageSpecificMessagesFile.importNewTransUnit(masterTransUnit, false, false, lastProcessedUnit);
        var translatedContent = changedTransUnit.targetContent();
        if (translatedContent) { // issue #68 set translated only, if it is really translated
            mergedTransUnit.translate(translatedContent);
            mergedTransUnit.setTargetState(dist_1.STATE_TRANSLATED);
        }
        return mergedTransUnit;
    };
    XliffMerge.prototype.areSourceReferencesEqual = function (ref1, ref2) {
        if ((util_1.isNullOrUndefined(ref1) && !util_1.isNullOrUndefined(ref2)) || (util_1.isNullOrUndefined(ref2) && !util_1.isNullOrUndefined(ref1))) {
            return false;
        }
        if (util_1.isNullOrUndefined(ref1) && util_1.isNullOrUndefined(ref2)) {
            return true;
        }
        // bot refs are set now, convert to set to compare them
        var set1 = new Set();
        ref1.forEach(function (ref) { set1.add(ref.sourcefile + ':' + ref.linenumber); });
        var set2 = new Set();
        ref2.forEach(function (ref) { set2.add(ref.sourcefile + ':' + ref.linenumber); });
        if (set1.size !== set2.size) {
            return false;
        }
        var match = true;
        set2.forEach(function (ref) {
            if (!set1.has(ref)) {
                match = false;
            }
        });
        return match;
    };
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param from
     * @param to
     * @param languageSpecificMessagesFile
     * @return a promise with the execution result as a summary report.
     */
    XliffMerge.prototype.autoTranslate = function (from, to, languageSpecificMessagesFile) {
        var _this = this;
        var serviceCall;
        var autotranslateEnabled = this.parameters.autotranslateLanguage(to);
        if (autotranslateEnabled) {
            serviceCall = this.autoTranslateService.autoTranslate(from, to, languageSpecificMessagesFile);
        }
        else {
            serviceCall = rxjs_1.of(new auto_translate_summary_report_1.AutoTranslateSummaryReport(from, to));
        }
        return serviceCall.pipe(operators_1.map(function (summary) {
            if (autotranslateEnabled) {
                if (summary.error() || summary.failed() > 0) {
                    _this.commandOutput.error(summary.content());
                }
                else {
                    _this.commandOutput.warn(summary.content());
                }
            }
            return summary;
        }));
    };
    return XliffMerge;
}());
exports.XliffMerge = XliffMerge;
//# sourceMappingURL=S:/experimente/ngx-i18nsupport/xliffmerge/xliff-merge.js.map