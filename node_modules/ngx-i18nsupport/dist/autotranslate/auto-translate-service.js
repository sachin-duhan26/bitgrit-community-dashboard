"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("util");
var request = require("request");
var rxjs_1 = require("rxjs");
var rxjs_2 = require("rxjs");
var operators_1 = require("rxjs/operators");
var MAX_SEGMENTS = 128;
var AutoTranslateService = /** @class */ (function () {
    function AutoTranslateService(apiKey) {
        this._request = request;
        this._apiKey = apiKey;
        this._rootUrl = 'https://translation.googleapis.com/';
    }
    /**
     * Change API key (just for tests).
     * @param apikey
     */
    AutoTranslateService.prototype.setApiKey = function (apikey) {
        this._apiKey = apikey;
    };
    /**
     * Translate an array of messages at once.
     * @param messages the messages to be translated
     * @param from source language code
     * @param to target language code
     * @return Observable with translated messages or error
     */
    AutoTranslateService.prototype.translateMultipleStrings = function (messages, from, to) {
        var _this = this;
        // empty array needs no translation and always works ... (#78)
        if (messages.length == 0) {
            return rxjs_2.of([]);
        }
        if (!this._apiKey) {
            return rxjs_2.throwError('cannot autotranslate: no api key');
        }
        if (!from || !to) {
            return rxjs_2.throwError('cannot autotranslate: source and target language must be set');
        }
        from = AutoTranslateService.stripRegioncode(from);
        to = AutoTranslateService.stripRegioncode(to);
        var allRequests = this.splitMessagesToGoogleLimit(messages).map(function (partialMessages) {
            return _this.limitedTranslateMultipleStrings(partialMessages, from, to);
        });
        return rxjs_2.forkJoin(allRequests).pipe(operators_1.map(function (allTranslations) {
            var all = [];
            for (var i = 0; i < allTranslations.length; i++) {
                all = all.concat(allTranslations[i]);
            }
            return all;
        }));
    };
    AutoTranslateService.prototype.splitMessagesToGoogleLimit = function (messages) {
        if (messages.length <= MAX_SEGMENTS) {
            return [messages];
        }
        var result = [];
        var currentPackage = [];
        var packageSize = 0;
        for (var i = 0; i < messages.length; i++) {
            currentPackage.push(messages[i]);
            packageSize++;
            if (packageSize >= MAX_SEGMENTS) {
                result.push(currentPackage);
                currentPackage = [];
                packageSize = 0;
            }
        }
        if (currentPackage.length > 0) {
            result.push(currentPackage);
        }
        return result;
    };
    /**
     * Return translation request, but messages must be limited to google limits.
     * Not more that 128 single messages.
     * @param messages
     * @param from
     * @param to
     * @return {Observable<string[]>} the translated strings
     */
    AutoTranslateService.prototype.limitedTranslateMultipleStrings = function (messages, from, to) {
        var realUrl = this._rootUrl + 'language/translate/v2' + '?key=' + this._apiKey;
        var translateRequest = {
            q: messages,
            target: to,
            source: from,
        };
        var options = {
            url: realUrl,
            body: translateRequest,
            json: true,
        };
        return this.post(realUrl, options).pipe(operators_1.map(function (data) {
            var body = data.body;
            if (!body) {
                throw new Error('no result received');
            }
            if (body.error) {
                if (body.error.code === 400) {
                    if (body.error.message === 'Invalid Value') {
                        throw new Error(util_1.format('Translation from "%s" to "%s" not supported', from, to));
                    }
                    throw new Error(util_1.format('Invalid request: %s', body.error.message));
                }
                else {
                    throw new Error(util_1.format('Error %s: %s', body.error.code, body.error.message));
                }
            }
            var result = body.data;
            return result.translations.map(function (translation) {
                return translation.translatedText;
            });
        }));
    };
    /**
     * Strip region code and convert to lower
     * @param lang
     * @return {string} lang without region code and in lower case.
     */
    AutoTranslateService.stripRegioncode = function (lang) {
        var langLower = lang.toLowerCase();
        for (var i = 0; i < langLower.length; i++) {
            var c = langLower.charAt(i);
            if (c < 'a' || c > 'z') {
                return langLower.substring(0, i);
            }
        }
        return langLower;
    };
    /**
     * Function to do a POST HTTP request
     *
     * @param uri {string}
     * @param options {CoreOptions}
     *
     * @return {Observable<InternalRequestResponse>}
     */
    AutoTranslateService.prototype.post = function (uri, options) {
        return this._call.apply(this, [].concat('post', uri, Object.assign({}, options || {})));
    };
    /**
     * Function to do a HTTP request for given method
     *
     * @param method {string}
     * @param uri {string}
     * @param options {CoreOptions}
     *
     * @return {Observable<InternalRequestResponse>}
     *
     * @private
     */
    AutoTranslateService.prototype._call = function (method, uri, options) {
        var _this = this;
        return rxjs_1.Observable.create(function (observer) {
            // build params array
            var params = [].concat(uri, Object.assign({}, options || {}), function (error, response, body) {
                if (error) {
                    return observer.error(error);
                }
                observer.next(Object.assign({}, {
                    response: response,
                    body: body
                }));
                observer.complete();
            });
            // _call request method
            try {
                _this._request[method].apply(_this._request, params);
            }
            catch (error) {
                observer.error(error);
            }
        });
    };
    return AutoTranslateService;
}());
exports.AutoTranslateService = AutoTranslateService;
//# sourceMappingURL=S:/experimente/ngx-i18nsupport/autotranslate/auto-translate-service.js.map