"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("util");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var entityDecoderLib = require("he");
var dist_1 = require("ngx-i18nsupport-lib/dist");
var auto_translate_service_1 = require("./auto-translate-service");
var auto_translate_result_1 = require("./auto-translate-result");
var auto_translate_summary_report_1 = require("./auto-translate-summary-report");
/**
 * Created by martin on 07.07.2017.
 * Service to autotranslate Transunits via Google Translate.
 */
var XliffMergeAutoTranslateService = /** @class */ (function () {
    function XliffMergeAutoTranslateService(apikey) {
        this.autoTranslateService = new auto_translate_service_1.AutoTranslateService(apikey);
    }
    /**
     * Auto translate file via Google Translate.
     * Will translate all new units in file.
     * @param from
     * @param to
     * @param languageSpecificMessagesFile
     * @return a promise with the execution result as a summary report.
     */
    XliffMergeAutoTranslateService.prototype.autoTranslate = function (from, to, languageSpecificMessagesFile) {
        return rxjs_1.forkJoin([
            this.doAutoTranslateNonICUMessages(from, to, languageSpecificMessagesFile)
        ].concat(this.doAutoTranslateICUMessages(from, to, languageSpecificMessagesFile)))
            .pipe(operators_1.map(function (summaries) {
            var summary = summaries[0];
            for (var i = 1; i < summaries.length; i++) {
                summary.merge(summaries[i]);
            }
            return summary;
        }));
    };
    /**
     * Collect all units that are untranslated.
     * @param languageSpecificMessagesFile
     * @return {ITransUnit[]}
     */
    XliffMergeAutoTranslateService.prototype.allUntranslatedTUs = function (languageSpecificMessagesFile) {
        // collect all units, that should be auto translated
        var allUntranslated = [];
        languageSpecificMessagesFile.forEachTransUnit(function (tu) {
            if (tu.targetState() === dist_1.STATE_NEW) {
                allUntranslated.push(tu);
            }
        });
        return allUntranslated;
    };
    XliffMergeAutoTranslateService.prototype.doAutoTranslateNonICUMessages = function (from, to, languageSpecificMessagesFile) {
        var _this = this;
        var allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);
        var allTranslatable = allUntranslated.filter(function (tu) { return util_1.isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()); });
        var allMessages = allTranslatable.map(function (tu) {
            return tu.sourceContentNormalized().asDisplayString();
        });
        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)
            .pipe(
        // #94 google translate might return &#.. entity refs, that must be decoded
        operators_1.map(function (translations) { return translations.map(function (encodedTranslation) { return entityDecoderLib.decode(encodedTranslation); }); }), operators_1.map(function (translations) {
            var summary = new auto_translate_summary_report_1.AutoTranslateSummaryReport(from, to);
            summary.setIgnored(allUntranslated.length - allTranslatable.length);
            for (var i = 0; i < translations.length; i++) {
                var tu = allTranslatable[i];
                var translationText = translations[i];
                var result = _this.autoTranslateNonICUUnit(tu, translationText);
                summary.addSingleResult(tu, result);
            }
            return summary;
        }), operators_1.catchError(function (err) {
            var failSummary = new auto_translate_summary_report_1.AutoTranslateSummaryReport(from, to);
            failSummary.setError(err.message, allMessages.length);
            return rxjs_1.of(failSummary);
        }));
    };
    XliffMergeAutoTranslateService.prototype.doAutoTranslateICUMessages = function (from, to, languageSpecificMessagesFile) {
        var _this = this;
        var allUntranslated = this.allUntranslatedTUs(languageSpecificMessagesFile);
        var allTranslatableICU = allUntranslated.filter(function (tu) { return !util_1.isNullOrUndefined(tu.sourceContentNormalized().getICUMessage()); });
        return allTranslatableICU.map(function (tu) {
            return _this.doAutoTranslateICUMessage(from, to, tu);
        });
    };
    /**
     * Translate single ICU Messages.
     * @param from
     * @param to
     * @param tu transunit to translate (must contain ICU Message)
     * @return {Observable<AutoTranslateSummaryReport>}
     */
    XliffMergeAutoTranslateService.prototype.doAutoTranslateICUMessage = function (from, to, tu) {
        var _this = this;
        var icuMessage = tu.sourceContentNormalized().getICUMessage();
        var categories = icuMessage.getCategories();
        // check for nested ICUs, we do not support that
        if (categories.find(function (category) { return !util_1.isNullOrUndefined(category.getMessageNormalized().getICUMessage()); })) {
            var summary = new auto_translate_summary_report_1.AutoTranslateSummaryReport(from, to);
            summary.setIgnored(1);
            return rxjs_1.of(summary);
        }
        var allMessages = categories.map(function (category) { return category.getMessageNormalized().asDisplayString(); });
        return this.autoTranslateService.translateMultipleStrings(allMessages, from, to)
            .pipe(
        // #94 google translate might return &#.. entity refs, that must be decoded
        operators_1.map(function (translations) { return translations.map(function (encodedTranslation) { return entityDecoderLib.decode(encodedTranslation); }); }), operators_1.map(function (translations) {
            var summary = new auto_translate_summary_report_1.AutoTranslateSummaryReport(from, to);
            var icuTranslation = {};
            for (var i = 0; i < translations.length; i++) {
                var translationText = translations[i];
                icuTranslation[categories[i].getCategory()] = translationText;
            }
            var result = _this.autoTranslateICUUnit(tu, icuTranslation);
            summary.addSingleResult(tu, result);
            return summary;
        }), operators_1.catchError(function (err) {
            var failSummary = new auto_translate_summary_report_1.AutoTranslateSummaryReport(from, to);
            failSummary.setError(err.message, allMessages.length);
            return rxjs_1.of(failSummary);
        }));
    };
    XliffMergeAutoTranslateService.prototype.autoTranslateNonICUUnit = function (tu, translatedMessage) {
        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translate(translatedMessage));
    };
    XliffMergeAutoTranslateService.prototype.autoTranslateICUUnit = function (tu, translation) {
        return this.autoTranslateUnit(tu, tu.sourceContentNormalized().translateICUMessage(translation));
    };
    XliffMergeAutoTranslateService.prototype.autoTranslateUnit = function (tu, translatedMessage) {
        var errors = translatedMessage.validate();
        var warnings = translatedMessage.validateWarnings();
        if (!util_1.isNullOrUndefined(errors)) {
            return new auto_translate_result_1.AutoTranslateResult(false, 'errors detected, not translated');
        }
        else if (!util_1.isNullOrUndefined(warnings)) {
            return new auto_translate_result_1.AutoTranslateResult(false, 'warnings detected, not translated');
        }
        else {
            tu.translate(translatedMessage);
            return new auto_translate_result_1.AutoTranslateResult(true, null); // success
        }
    };
    return XliffMergeAutoTranslateService;
}());
exports.XliffMergeAutoTranslateService = XliffMergeAutoTranslateService;
//# sourceMappingURL=S:/experimente/ngx-i18nsupport/autotranslate/xliff-merge-auto-translate-service.js.map